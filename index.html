<!doctype html>
<html lang="ko">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>동호회 출석 체크</title>
  <style>
    body { font-family: system-ui, sans-serif; background:#f7f7f7; padding:20px; }
    .box { max-width:560px; margin:auto; background:#fff; padding:18px 18px 14px;
           border-radius:14px; box-shadow:0 10px 25px rgba(0,0,0,.08); }
    h2 { margin: 6px 0 10px; }
    label { font-size:13px; color:#444; display:block; margin-top:10px; }
    input { width:100%; padding:12px; border:1px solid #ddd; border-radius:12px; font-size:16px; }
    button { width:100%; padding:14px; font-size:18px; border-radius:12px;
             border:0; background:#2563eb; color:#fff; cursor:pointer; margin-top:12px; }
    button:disabled { background:#999; cursor:not-allowed; }
    pre { background:#f1f5f9; padding:12px; border-radius:12px; margin-top:14px; white-space:pre-wrap; }
    .small { font-size:12px; color:#555; margin-top:10px; line-height:1.45; }
    .pill { display:inline-block; padding:4px 8px; background:#eef2ff; border-radius:999px; font-size:12px; color:#3730a3; margin-right:6px; }
    .warn { background:#fff7ed; border:1px solid #fed7aa; color:#9a3412; padding:10px; border-radius:12px; margin-top:10px; }
    .ok { background:#ecfdf5; border:1px solid #a7f3d0; color:#065f46; padding:10px; border-radius:12px; margin-top:10px; }
    .row { display:flex; gap:10px; }
    .row > div { flex:1; }
    .copybtn { margin-top:8px; background:#111827; }
  </style>
</head>
<body>
  <div class="box">
    <h2>📍 동호회 출석 체크</h2>

    <div class="small" id="metaWrap">
      <span class="pill" id="meta1"></span>
      <span class="pill" id="meta2"></span>
      <span class="pill" id="meta3"></span>
    </div>

    <div id="incogBox" class="warn" style="display:none;"></div>

    <label>Knox ID (필수)</label>
    <input id="knox" placeholder="예: seonhong.kim / abc123" autocomplete="off" />

    <label>이름 (선택)</label>
    <input id="name" placeholder="예: 김선홍" autocomplete="off" />

    <div class="row">
      <div>
        <label>기기 토큰 (자동 생성, 사후 검증용)</label>
        <input id="deviceToken" readonly />
      </div>
      <div style="max-width:170px;">
        <label>&nbsp;</label>
        <button class="copybtn" onclick="copyToken()">토큰 복사</button>
      </div>
    </div>

    <label>기기 지문 해시 (자동 생성, 사후 검증용)</label>
    <input id="fingerprint" readonly />

    <button id="btn" onclick="checkIn()">출석 완료</button>

    <pre id="out">안내: Knox ID 입력 후 버튼을 누르면 1회성으로 위치·시간이 확인됩니다.</pre>

    <div class="small">
      정책 안내:
      <br>• 시크릿 모드/비정상 환경으로 의심될 경우 출석 결과에 표기됩니다.
      <br>• GPS 조작(위치 변경 앱/가상 위치 등) 의심 시 출석이 완료되지 않으며 재시도 안내됩니다.
      <br>• 출석 완료 화면을 캡처하여 제출하세요(감사 증적).
    </div>
  </div>

<script>
  // ----------------- helpers -----------------
  function qs(name, def="") {
    const v = new URLSearchParams(location.search).get(name);
    return (v === null || v === undefined || v === "") ? def : v;
  }
  function toFixed(n, d=6) { return (typeof n === "number") ? n.toFixed(d) : String(n); }
  function setOut(msg) { document.getElementById("out").textContent = msg; }

  function uuid() {
    return ([1e7]+-1e3+-4e3+-8e3+-1e11).replace(/[018]/g, c =>
      (c ^ crypto.getRandomValues(new Uint8Array(1))[0] & (15 >> (c / 4))).toString(16)
    );
  }

  async function sha256Hex(input) {
    const data = new TextEncoder().encode(input);
    const hash = await crypto.subtle.digest("SHA-256", data);
    return Array.from(new Uint8Array(hash)).map(b => b.toString(16).padStart(2, "0")).join("");
  }

  async function getDeviceFingerprintHash() {
    const parts = [
      navigator.userAgent || "",
      navigator.language || "",
      (Intl.DateTimeFormat().resolvedOptions().timeZone || ""),
      navigator.platform || "",
      String(screen.width) + "x" + String(screen.height),
      String(window.devicePixelRatio || ""),
      String(navigator.hardwareConcurrency || ""),
      String(navigator.deviceMemory || ""),
    ].join("|");
    return await sha256Hex(parts);
  }

  function haversineMeters(lat1, lon1, lat2, lon2) {
    const R = 6371000;
    const toRad = (x) => x * Math.PI / 180;
    const dLat = toRad(lat2-lat1);
    const dLon = toRad(lon2-lon1);
    const a = Math.sin(dLat/2)**2 + Math.cos(toRad(lat1))*Math.cos(toRad(lat2))*Math.sin(dLon/2)**2;
    return 2*R*Math.asin(Math.sqrt(a));
  }

  function normalizeKnox(s) {
    return String(s || "").trim().toLowerCase();
  }

  // ----------------- config (from URL) -----------------
  const EVENT_ID = qs("eventId", "event");
  const TARGET_LAT = parseFloat(qs("lat", ""));     // 행사 장소 위도
  const TARGET_LNG = parseFloat(qs("lng", ""));     // 행사 장소 경도
  const RADIUS_M  = parseFloat(qs("radius", "0"));  // 반경(m). 0이면 지오펜스 미사용(권장X)
  const ACC_MAX   = parseFloat(qs("accMax", "150")); // 정확도 허용(±m)
  const MAX_JUMP_KM  = parseFloat(qs("maxJumpKm", "3"));   // 순간이동 탐지: 거리(km)
  const MAX_JUMP_MIN = parseFloat(qs("maxJumpMin", "10")); // 순간이동 탐지: 시간(min)

  document.getElementById("meta1").textContent = `eventId=${EVENT_ID}`;
  document.getElementById("meta2").textContent = (Number.isFinite(RADIUS_M) && RADIUS_M > 0)
    ? `geofence=${Math.round(RADIUS_M)}m`
    : `geofence=OFF(권장X)`;
  document.getElementById("meta3").textContent = `accMax=${Math.round(ACC_MAX)}m`;

  // ----------------- device token (stored) -----------------
  const DEVICE_KEY = "club_device_token_v2";
  let deviceToken = localStorage.getItem(DEVICE_KEY);
  if (!deviceToken) {
    deviceToken = uuid();
    localStorage.setItem(DEVICE_KEY, deviceToken);
  }
  document.getElementById("deviceToken").value = deviceToken;

  // ----------------- fingerprint (environment) -----------------
  let fingerprintHash = "";
  (async () => {
    fingerprintHash = await getDeviceFingerprintHash();
    document.getElementById("fingerprint").value = fingerprintHash;
  })();

  // ----------------- incognito suspicion (heuristics) -----------------
  // NOTE: No perfect detection. We only "suspect" and clearly label it.
  async function isIncognitoSuspected() {
    // 1) Storage persistence test
    let lsOk = true;
    try {
      const k = "__incog_test__";
      localStorage.setItem(k, "1");
      localStorage.removeItem(k);
    } catch (e) {
      lsOk = false;
    }

    // 2) Storage quota heuristic (some browsers give very small quota in private mode)
    let quotaSmall = false;
    if (navigator.storage && navigator.storage.estimate) {
      try {
        const est = await navigator.storage.estimate();
        // Heuristic threshold. If quota is extremely small, suspect private mode.
        if (est && typeof est.quota === "number" && est.quota > 0 && est.quota < 120 * 1024 * 1024) {
          quotaSmall = true;
        }
      } catch (e) {}
    }

    // 3) Safari private mode used to throw on indexedDB. Not reliable, but signal.
    let idbFail = false;
    try {
      const req = indexedDB.open("__idb_test__", 1);
      await new Promise((resolve, reject) => {
        req.onerror = () => reject(new Error("idb error"));
        req.onsuccess = () => resolve(true);
        req.onupgradeneeded = () => resolve(true);
      });
    } catch (e) {
      idbFail = true;
    }

    // If multiple weak signals, mark as suspected
    const score = (lsOk ? 0 : 1) + (quotaSmall ? 1 : 0) + (idbFail ? 1 : 0);
    return score >= 2;
  }

  let incognitoSuspected = false;
  (async () => {
    incognitoSuspected = await isIncognitoSuspected();
    if (incognitoSuspected) {
      const box = document.getElementById("incogBox");
      box.style.display = "block";
      box.textContent =
        "⚠️ 시크릿 모드 또는 비정상 브라우저 환경으로 의심됩니다.\n" +
        "가능하면 일반 모드(Safari/Chrome 기본 모드)에서 다시 진행해 주세요.\n" +
        "※ 본 표시는 100% 확정이 아닌 ‘의심’ 표시입니다.";
    }
  })();

  // ----------------- copy token -----------------
  async function copyToken() {
    try {
      await navigator.clipboard.writeText(deviceToken);
      setOut("✅ 기기 토큰이 복사됐어.\n(사후 검증을 위해 캡처에도 함께 남겨줘)");
    } catch (e) {
      setOut("복사 권한이 막혀있어.\n토큰을 길게 눌러 직접 복사해줘:\n" + deviceToken);
    }
  }

  // ----------------- anti-spoof (deterrence & detection) -----------------
  // We store last known check-in to detect impossible jumps on the same device.
  const LAST_KEY = "club_last_checkin_v1"; // stores {t,lat,lng}
  function getLast() {
    try { return JSON.parse(localStorage.getItem(LAST_KEY) || "null"); } catch { return null; }
  }
  function setLast(obj) {
    localStorage.setItem(LAST_KEY, JSON.stringify(obj));
  }

  function spoofBlockedReason(current) {
    // 1) accuracy gate
    if (Number.isFinite(ACC_MAX) && current.acc > ACC_MAX) {
      return `GPS 정확도가 낮아 출석을 완료할 수 없습니다.\n정확도(±m): ${Math.round(current.acc)} / 허용: ${Math.round(ACC_MAX)}`;
    }

    // 2) geofence gate (recommended ON)
    if (Number.isFinite(RADIUS_M) && RADIUS_M > 0 && Number.isFinite(TARGET_LAT) && Number.isFinite(TARGET_LNG)) {
      const dist = haversineMeters(TARGET_LAT, TARGET_LNG, current.lat, current.lng);
      if (dist > RADIUS_M) {
        return `행사 장소 반경 밖입니다.\n거리(m): ${Math.round(dist)} / 반경: ${Math.round(RADIUS_M)}`;
      }
    } else {
      // If geofence is off, we cannot enforce "no spoof". We show a caution.
      // Not blocking, but later we label it.
      return null;
    }

    // 3) jump detection on same device
    const last = getLast();
    if (last && last.lat && last.lng && last.t) {
      const dtMin = (Date.now() - last.t) / 60000;
      const dKm = haversineMeters(last.lat, last.lng, current.lat, current.lng) / 1000;
      if (dtMin >= 0 && dtMin < MAX_JUMP_MIN && dKm > MAX_JUMP_KM) {
        return `비정상 이동(순간이동) 패턴이 감지되어 출석을 완료할 수 없습니다.\n` +
               `이전 출석 이후 경과(min): ${dtMin.toFixed(1)} / 허용: ${MAX_JUMP_MIN}\n` +
               `이동 거리(km): ${dKm.toFixed(2)} / 허용: ${MAX_JUMP_KM}`;
      }
    }

    return null;
  }

  // ----------------- main -----------------
  async function checkIn() {
    const btn = document.getElementById("btn");
    btn.disabled = true;
    btn.textContent = "위치 확인 중...";

    const knox = normalizeKnox(document.getElementById("knox").value);
    const name = document.getElementById("name").value.trim();

    if (!knox) {
      setOut("Knox ID를 입력해줘.");
      btn.disabled = false; btn.textContent = "출석 완료";
      return;
    }

    if (!navigator.geolocation) {
      setOut("이 브라우저는 위치 기능을 지원하지 않아.");
      btn.disabled = false; btn.textContent = "출석 완료";
      return;
    }

    navigator.geolocation.getCurrentPosition(
      async (pos) => {
        const now = new Date();
        const current = {
          lat: pos.coords.latitude,
          lng: pos.coords.longitude,
          acc: pos.coords.accuracy
        };

        // Ensure fingerprint is available
        if (!fingerprintHash) {
          fingerprintHash = await getDeviceFingerprintHash();
          document.getElementById("fingerprint").value = fingerprintHash;
        }

        // anti-spoof gates
        const blockReason = spoofBlockedReason(current);
        if (blockReason) {
          setOut(
            "❌ 출석 불가 (GPS 조작/비정상 환경 방지)\n\n" +
            blockReason + "\n\n" +
            "조치 안내:\n" +
            "1) 실내면 창가/야외로 이동 후 재시도\n" +
            "2) 위치 서비스 ON, 정확도 향상 후 재시도\n" +
            "3) 위치 변경 앱(가상 위치) 사용 시 OFF 후 재시도"
          );
          btn.disabled = false; btn.textContent = "출석 완료";
          return;
        }

        // Save last checkin for jump detection (same device)
        setLast({ t: Date.now(), lat: current.lat, lng: current.lng });

        // Labeling if geofence OFF
        const geofenceOff = !(Number.isFinite(RADIUS_M) && RADIUS_M > 0 && Number.isFinite(TARGET_LAT) && Number.isFinite(TARGET_LNG));

        // Duplicate prevention on same device + same event + same knox (optional)
        const DUP_KEY = `checkin_done_${EVENT_ID}_${knox}`;
        if (localStorage.getItem(DUP_KEY) === "DONE") {
          setOut(
            "⚠️ 이미 이 기기에서 동일 행사/동일 Knox ID로 출석 완료된 기록이 있습니다.\n\n" +
            `eventId: ${EVENT_ID}\nknoxId: ${knox}\n` +
            `deviceToken: ${deviceToken}\nfingerprint: ${fingerprintHash}\n`
          );
          btn.textContent = "이미 완료";
          return;
        }
        localStorage.setItem(DUP_KEY, "DONE");

        setOut(
          "✅ 출석 완료\n\n" +
          `eventId: ${EVENT_ID}\n` +
          `knoxId: ${knox}\n` +
          (name ? `name: ${name}\n` : "") +
          `time: ${now.toLocaleString()}\n` +
          `lat: ${toFixed(current.lat)}\n` +
          `lng: ${toFixed(current.lng)}\n` +
          `accuracy(±m): ${Math.round(current.acc)}\n\n` +
          `incognitoSuspected: ${incognitoSuspected ? "true" : "false"}\n` +
          `geofenceOff: ${geofenceOff ? "true" : "false"}\n\n` +
          `deviceToken: ${deviceToken}\n` +
          `fingerprint: ${fingerprintHash}\n` +
          `userAgent: ${navigator.userAgent}\n\n` +
          "이 화면을 캡처해서 제출하면 됩니다."
        );

        btn.textContent = "✅ 완료됨";
      },
      (err) => {
        setOut(
          "위치 획득 실패: " + err.message + "\n\n" +
          "해결 팁:\n" +
          "- 브라우저 위치 권한 허용\n" +
          "- 휴대폰 위치 서비스 ON\n" +
          "- 카톡 인앱 브라우저면 '브라우저에서 열기'\n" +
          "- iPhone은 Safari, Android는 Chrome 권장"
        );
        btn.disabled = false; btn.textContent = "출석 완료";
      },
      { enableHighAccuracy: true, timeout: 12000, maximumAge: 0 }
    );
  }
</script>
</body>
</html>
